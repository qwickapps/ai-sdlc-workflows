workflow: jira-ticket-implementation
description: Complete implementation of a JIRA ticket from start to finish
trigger: User provides JIRA ticket number (RS-XXXXX)

prerequisites:
  - JIRA ticket number
  - Access to codebase
  - Master branch up to date

steps:
  - step: 1
    name: analyze-requirements
    agent: architect
    actions:
      - Read JIRA ticket completely (description, acceptance criteria, all comments)
      - Search KB for related components
      - Identify affected systems and files
      - Document approach summary in .cascade/engineering/analysis/ANALYSIS-<ticket>.md
      - Attach analysis document to JIRA ticket (via JIRA API/CLI)
      - Verify understanding with user

    validation_gates:
      - Ticket read and understood
      - No ambiguous requirements
      - Approach documented
      - Document attached to ticket (or user notified if failed)
      - User confirms understanding
      - No assumptions remain

    stop_if:
      - Requirements unclear
      - Multiple valid approaches
      - Significant architectural impact

    outputs:
      - Approach summary document
      - Affected components list
      - KB entry (if architectural decision)

    next: create-worktree

  - step: 2
    name: create-worktree
    agent: devops
    actions:
      - Determine ticket type (bug/feature/hotfix) from JIRA ticket
      - Determine branch naming (bugfix/RS-XXXXX, feature/RS-XXXXX, or hotfix/RS-XXXXX)
      - Create git worktree with new branch in ../worktrees/<type>/RS-XXXXX
      - Execute "git worktree add ../worktrees/<type>/RS-XXXXX -b <type>/RS-XXXXX"
      - Change directory to worktree "cd ../worktrees/<type>/RS-XXXXX"
      - Verify worktree and branch created successfully

    validation_gates:
      - Branch name matches pattern (bugfix/feature/hotfix + RS-XXXXX)
      - Worktree created successfully
      - Branch created in worktree
      - Working directory changed to worktree

    stop_if:
      - Branch already exists
      - Worktree creation fails
      - Naming convention unclear

    outputs:
      - Branch name
      - Worktree path
      - Worktree creation confirmation

    next: implement-code

  - step: 3
    name: implement-code
    agent: coder
    actions:
      - Read existing code in affected files
      - Implement changes following existing patterns
      - Add/update tests
      - Ensure code is immediately runnable
      - Add all necessary imports and dependencies
    
    validation_gates:
      - Code compiles/runs without errors
      - All imports added
      - No placeholder code
      - Tests written/updated
      - Follows existing patterns
    
    stop_if:
      - Existing pattern unclear
      - Breaking changes required
      - Dependencies need discussion
      - Uncertain about approach
    
    outputs:
      - Modified source files
      - Test files
      - Configuration changes (if any)
    
    next: review-code

  - step: 4
    name: review-code
    agent: reviewer
    actions:
      - Verify all acceptance criteria met
      - Check code quality
      - Validate test coverage
      - Ensure documentation updated
      - Complete review checklist
    
    validation_gates:
      - All requirements met
      - Code quality acceptable
      - Tests adequate
      - Documentation current
      - No issues found
    
    stop_if:
      - Requirements not met
      - Code quality issues
      - Test coverage insufficient
      - Issues found
    
    outputs:
      - Review checklist (completed)
      - Approval status
    
    next: qa-validation
    next_if_issues: implement-code

  - step: 5
    name: qa-validation
    agent: qa
    actions:
      - Create test plan
      - Verify test coverage
      - Document test scenarios
      - Validate functionality
    
    validation_gates:
      - Test plan complete
      - Coverage adequate
      - All scenarios tested
      - Tests pass
    
    stop_if:
      - Test coverage insufficient
      - Test failures
      - Critical scenarios missing
    
    outputs:
      - Test plan
      - Test results
    
    next: commit-and-push
    next_if_issues: implement-code

  - step: 6
    name: commit-and-push
    agent: devops
    actions:
      - Validate commit message format
      - Commit changes
      - Push to remote
    
    validation_gates:
      - Commit message matches regex
      - Commit successful
      - Push successful
    
    stop_if:
      - Commit message invalid
      - Push fails
    
    outputs:
      - Commit SHA
      - Push confirmation
    
    next: create-pull-request

  - step: 7
    name: create-pull-request
    agent: devops
    actions:
      - Create PR from branch to master
      - Add title from ticket summary
      - Add description with JIRA link
      - Add changes summary
    
    validation_gates:
      - PR created successfully
      - Title and description complete
      - JIRA link included
    
    stop_if:
      - PR creation fails
    
    outputs:
      - PR URL
    
    next: generate-report

  - step: 8
    name: generate-report
    agent: tech-writer
    actions:
      - Generate completion report
      - Update KB if architectural changes
      - Save report to .cascade/engineering/reports/implementation/
      - Attach completion report to JIRA ticket (via JIRA API/CLI)

    validation_gates:
      - Report complete
      - All sections filled
      - Facts verified
      - Report attached to ticket (or user notified if failed)
      - Saved correctly
    
    outputs:
      - Completion report path
      - KB updates (if any)
    
    next: complete

completion_criteria:
  - All steps completed successfully
  - PR created
  - Report generated
  - No outstanding issues

rollback_on_failure:
  - Document failure reason
  - Preserve work done
  - Report to user
